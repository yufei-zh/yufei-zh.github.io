<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[xml解析——以人名规范档为例]]></title>
    <url>%2F2018%2F11%2F14%2Fxml%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[XML 指可扩展标记语言（eXtensible Markup Language）。XML 被设计用来传输和存储数据。而HTML被用来显示数据。 XML是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。 Python对XML解析有三种方式：SAX，DOM，以及ElementTree。 SAX (simple API for XML )python 标准库包含SAX解析器，SAX用事件驱动模型，通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件。 DOM(Document Object Model)将XML数据在内存中解析成一个树，通过对树的操作来操作XML。 ElementTree(元素树)ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少。 注：因DOM需要将XML数据映射到内存中的树，一是比较慢，二是比较耗内存，而SAX流式读取XML文件，比较快，占用内存少，但需要用户实现回调函数。本文使用用ElementTree方式，以名称规范档的下载文本为例。 在ElementTree中，具体节点的方法主要包括 tag(标签) attrib(属性) find(寻找节点) set(设置属性) iter(遍历节点) get(获取节点) 解析XMLfrom xml.etree import ElementTree as ET #第一种方式 # 打开文件，读取XML内容 str_xml = open(&apos;xo.xml&apos;, &apos;r&apos;).read() # 将字符串解析成xml特殊对象，root代指xml文件的根节点 root = ET.XML(str_xml) from xml.etree import ElementTree as ET #第二种方式 # 直接解析xml文件 tree = ET.parse(&quot;xo.xml&quot;) # 获取xml文件的根节点 root = tree.getroot() 操作XML遍历XML文档的所有内容from xml.etree import ElementTree as ET # 直接解析xml文件 tree = ET.parse(&quot;test.xml&quot;) # 获取xml文件的根节点 root = tree.getroot() ### 操作 # 顶层标签 print(root.tag) # 遍历XML文档的第二层 for child in root: # 第二层节点的标签名称和标签属性 print(child.tag, child.attrib) # 遍历XML文档的第三层 for i in child: # 第二层节点的标签内容 print(i.text) 遍历XML中指定的节点from xml.etree import ElementTree as ET # 直接解析xml文件 tree = ET.parse(&quot;test.xml&quot;) # 获取xml文件的根节点 root = tree.getroot() # 顶层标签 print(root.tag) # 遍历XML中所有的属性名节点 for node in root.iter(&apos;属性名&apos;): # 节点的标签名称和内容 print(node.text) 修改节点内容xml解析中，要注意修改或者写出XML文件都是在内存中进行，如果要在文件中保存修改，要使用tree的write()方法。set()可设置属性，remove()可删除制定节点，例： # 直接解析xml文件 tree = ET.parse(&quot;xo.xml&quot;) # 获取xml文件的根节点 root = tree.getroot() ############ 操作 ############ # 顶层标签 print(root.tag) # 循环所有的year节点 for node in root.iter(&apos;year&apos;): # 将year节点中的内容自增一 new_year = int(node.text) + 1 node.text = str(new_year) # 设置属性 node.set(&apos;name&apos;, &apos;alex&apos;) node.set(&apos;age&apos;, &apos;18&apos;) # 删除属性 del node.attrib[&apos;name&apos;] ############ 保存文件 ############ tree.write(&quot;newnew.xml&quot;, encoding=&apos;utf-8&apos;) 创建XML文档方式一from xml.etree import ElementTree as ET # 创建根节点 root = ET.Element(&quot;famliy&quot;) # 创建节点大儿子 son1 = ET.Element(&apos;son&apos;, {&apos;name&apos;: &apos;儿1&apos;}) # 创建小儿子 son2 = ET.Element(&apos;son&apos;, {&quot;name&quot;: &apos;儿2&apos;}) # 在大儿子中创建两个孙子 grandson1 = ET.Element(&apos;grandson&apos;, {&apos;name&apos;: &apos;儿11&apos;}) grandson2 = ET.Element(&apos;grandson&apos;, {&apos;name&apos;: &apos;儿12&apos;}) son1.append(grandson1) son1.append(grandson2) # 把儿子添加到根节点中 root.append(son1) root.append(son1) tree = ET.ElementTree(root) tree.write(&apos;oooo.xml&apos;,encoding=&apos;utf-8&apos;, short_empty_elements=False) 方式二from xml.etree import ElementTree as ET # 创建根节点 root = ET.Element(&quot;famliy&quot;) # 创建大儿子 # son1 = ET.Element(&apos;son&apos;, {&apos;name&apos;: &apos;儿1&apos;}) son1 = root.makeelement(&apos;son&apos;, {&apos;name&apos;: &apos;儿1&apos;}) # 创建小儿子 # son2 = ET.Element(&apos;son&apos;, {&quot;name&quot;: &apos;儿2&apos;}) son2 = root.makeelement(&apos;son&apos;, {&quot;name&quot;: &apos;儿2&apos;}) # 在大儿子中创建两个孙子 # grandson1 = ET.Element(&apos;grandson&apos;, {&apos;name&apos;: &apos;儿11&apos;}) grandson1 = son1.makeelement(&apos;grandson&apos;, {&apos;name&apos;: &apos;儿11&apos;}) # grandson2 = ET.Element(&apos;grandson&apos;, {&apos;name&apos;: &apos;儿12&apos;}) grandson2 = son1.makeelement(&apos;grandson&apos;, {&apos;name&apos;: &apos;儿12&apos;}) son1.append(grandson1) son1.append(grandson2) # 把儿子添加到根节点中 root.append(son1) root.append(son1) tree = ET.ElementTree(root) tree.write(&apos;oooo.xml&apos;,encoding=&apos;utf-8&apos;, short_empty_elements=False) 方式三from xml.etree import ElementTree as ET # 创建根节点 root = ET.Element(&quot;famliy&quot;) # 创建节点大儿子 son1 = ET.SubElement(root, &quot;son&quot;, attrib={&apos;name&apos;: &apos;儿1&apos;}) # 创建小儿子 son2 = ET.SubElement(root, &quot;son&quot;, attrib={&quot;name&quot;: &quot;儿2&quot;}) # 在大儿子中创建一个孙子 grandson1 = ET.SubElement(son1, &quot;age&quot;, attrib={&apos;name&apos;: &apos;儿11&apos;}) grandson1.text = &apos;孙子&apos; et = ET.ElementTree(root) #生成文档对象 et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;, xml_declaration=True, short_empty_elements=False) 名称规范档文本名称规范档没有提供批量下载同一人物的接口，在数据量大的实验需求中，设计实现了处理批量文本的方法。 首先，在下载的同一文档中包含不同ID号的多条人物数据，分别以&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 开头，以结尾，因此第一步，逐行读取文本，匹配结尾标识符“\n”，匹配成功则将先前读取的xml文档写出到新的文件，并给与新的命名以区别不同文本，实现代码如下： def file_seperate(file_path,to_path): for fileName in os.listdir(file_path): f1 = open(file_path+&quot;/&quot;+fileName,&apos;r&apos;,encoding=&quot;utf-8&quot;) # print(file_path+&quot;/&quot;+fileName) text = &quot;&quot; num = 1 for content in f1.readlines(): text += content if &quot;&lt;/collection&gt;&quot;+&quot;\n&quot; == content: num_str = str(num) f2 = open(to_path + &quot;/0&quot; + num_str + fileName ,&apos;w&apos;,encoding=&quot;utf-8&quot;) f2.write(text) f2.close() text = &quot;&quot; num = num + 1 f1.close() 解析结果可得（以沈从文为例）01沈从文.xml、02沈从文.xml、03沈从文.xml，进一步分析，在每一篇XML文件，要获取具体属性值构建目标文本集，为进一步的数据处理提供依据。根据研究需要，获取xml文件中的collection&gt;&gt;record&gt;&gt;datafield&gt;&gt;subfield字段，并限定具体属性的subfield字段，如{‘code’: ‘a’}、{‘code’: ‘f’}、 {‘code’: ‘3’}、{‘code’: ‘u’}，循环读取进行匹配，匹配成功则构建新的目标文本，与原文本同名。实现代码如下： def xml_parse(file_path,Target_path): for fileName in os.listdir(file_path): file = file_path+&quot;/&quot;+fileName text = &apos;&apos; tree = ET.parse(file) root = tree.getroot() for node in root: for node_node in node: if node_node.attrib == {&apos;tag&apos;: &apos;200&apos;, &apos;ind1&apos;: &apos; &apos;, &apos;ind2&apos;: &apos;0&apos;} or node_node.attrib =={&apos;tag&apos;: &apos;400&apos;, &apos;ind1&apos;: &apos; &apos;, &apos;ind2&apos;: &apos;0&apos;} or node_node.attrib =={&apos;tag&apos;: &apos;810&apos;, &apos;ind1&apos;: &apos; &apos;, &apos;ind2&apos;: &apos; &apos;} or node_node.attrib =={&apos;tag&apos;: &apos;830&apos;, &apos;ind1&apos;: &apos; &apos;, &apos;ind2&apos;: &apos; &apos;} or node_node.attrib =={&apos;tag&apos;: &apos;856&apos;, &apos;ind1&apos;: &apos;4&apos;, &apos;ind2&apos;: &apos; &apos;}: for subfield in node_node: if subfield.attrib == {&apos;code&apos;: &apos;a&apos;} or subfield.attrib == {&apos;code&apos;: &apos;f&apos;} or subfield.attrib == {&apos;code&apos;: &apos;3&apos;} or subfield.attrib == {&apos;code&apos;: &apos;u&apos;}: text = text + subfield.text print(text) f = open(Target_path+&quot;/&quot;+fileName,&apos;w&apos;,encoding=&apos;utf-8&apos;) f.write(text) f.close() 主函数如下，分别设定原始路径，处理文件路径，目标文件路径： if __name__ == &quot;__main__&quot;: path_Source = &quot;D:/study/name_cluster/test/test02/data-Source&quot; path_Separate = &quot;D:/study/name_cluster/test/test02/data-Separate&quot; path_Target = &quot;D:/study/name_cluster/test/test02/data-Target&quot; file_seperate(path_Source,path_Separate) xml_parse(path_Separate,path_Target)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python、xml、文本解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python安装第三方模块]]></title>
    <url>%2F2018%2F11%2F12%2Fpython%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[python安装第三方模块有两种方式：pip安装和下载安装的方式。 pip安装 windows安装python的过程中，确保勾选了pip和Add python.exe to Path选项 在命令提示符中，尝试运行pip，会有操作命令的提示。（如果没有pip使用提示，重装python并勾选pip即可） 以requests模块为例，requests模块以代码形式，模拟浏览器HTTP请求访问网页，并返回具体内容，是python做爬虫，实现网络信息获取的基础。 安装具体步骤：win+R——&gt;cmd——&gt;pip install requests 提示成功安装了10月15日版本的requests模块。 requests模块利用requests模块请求百度首页内容import requestsresponse = requests.get(“http://www.baidu.com&quot;)response.encoding = “utf-8”result = response.textprint(result) 模块下载安装 下载代码，例：requests的下载地址 https://pypi.org/project/requests/#files 解压文件 利用cd进入解压目录 执行 python setup.py install]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python、requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据类型练习]]></title>
    <url>%2F2018%2F11%2F10%2Fpython%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[元素分类有如下值集合 [11,22,33,44,55,66,77,88,99,90…]，将所有大于 66 的值保存至字典的第一个key中，将小于 66 的值保存至第二个key的值中。即： {‘k1’: 大于66的所有值, ‘k2’: 小于66的所有值} li=[11,22,33,44,55,66,77,88,99,90] dic={&apos;k1&apos;:[ ],&apos;k2&apos;:[ ]} for i in li: print(i) if i &gt;70: dic[&apos;k1&apos;].append(i) else: dic[&apos;k2&apos;].append(i) print(dic) 查找查找列表中元素，移除每个元素的空格，并查找以 a或A开头 并且以 c 结尾的所有元素。 li = [“alec”, “ aric”, “Alex”, “Tony”, “rain”] tu = (“alec”, “ aric”, “Alex”, “Tony”, “rain”) dic = {‘k1’: “alex”, ‘k2’: ‘ aric’, “k3”: “Alex”, “k4”: “Tony”} li = [&quot;alec&quot;, &quot; aric&quot;, &quot;Alex&quot;, &quot;Tony&quot;, &quot;rain&quot;] tu = (&quot;alec&quot;, &quot; aric&quot;, &quot;Alex&quot;, &quot;Tony&quot;, &quot;rain&quot;) dic = {&apos;k1&apos;: &quot;alex&quot;, &apos;k2&apos;: &apos; aric&apos;, &quot;k3&quot;: &quot;Alex&quot;, &quot;k4&quot;: &quot;Tony&quot;} ret = [] for i in li: i = i.strip() if i.startswith(&apos;a&apos;or&apos;A&apos;) and i.endswith(&apos;c&apos;): ret.append(i) for i in tu: i = i.strip() if i.startswith(&apos;a&apos;or&apos;A&apos;) and i.endswith(&apos;c&apos;): ret.append(i) for i in dic: i = i.strip() if i.startswith(&apos;a&apos;or&apos;A&apos;) and i.endswith(&apos;c&apos;): ret.append(i) print(ret) #结果：[&apos;alec&apos;, &apos;aric&apos;, &apos;alec&apos;, &apos;aric&apos;] 输出商品列表，用户输入序号，显示用户选中的商品商品 li = [“手机”, “电脑”, ‘鼠标垫’, ‘游艇’] li=[&quot;手机&quot;,&quot;电脑&quot;,&quot;鼠标垫&quot;,&quot;游艇&quot;] print(&quot;0是手机，1是电脑，2是鼠标垫，3是游艇&quot;) num=input(&quot;请输入数字：&quot;) if num==&apos;0&apos;: print(li[0]) elif num==&apos;1&apos;: print(li[1]) elif num==&apos;2&apos;: print(li[2]) elif num==&apos;3&apos;: print(li[3]) else: print(&apos;&apos;) 购物车功能要求： 要求用户输入总资产，例如：2000 显示商品列表，让用户根据序号选择商品，加入购物车 购买，如果商品总额大于总资产，提示账户余额不足，否则，购买成功。 附加：可充值、某商品移除购物车 goods = [ {&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 1999}, {&quot;name&quot;: &quot;鼠标&quot;, &quot;price&quot;: 10}, {&quot;name&quot;: &quot;游艇&quot;, &quot;price&quot;: 20}, {&quot;name&quot;: &quot;美女&quot;, &quot;price&quot;: 998}, ] print(&quot;输入0购买电脑，输入1购买鼠标，输入2购买游艇，输入3购买美女，输入其他数值，结算购物车&quot;) li = [] total = input(&quot;请输入总金额：&quot;) while True: num = input(&quot;输入要购买的序号：&quot;) if int(num) == 0: li.append(goods[0][&apos;price&apos;]) elif int(num) == 1: li.append(goods[1][&apos;price&apos;]) elif int(num) == 2: li.append(goods[2][&apos;price&apos;]) elif int(num) == 3: li.append(goods[3][&apos;price&apos;]) else: break sum = 0 for i in li: sum +=i print(sum) if sum&gt;int(total): print(&quot;余额不足&quot;) else: print(&quot;购买成功&quot;)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据类型]]></title>
    <url>%2F2018%2F11%2F10%2Fpython%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[算数运算https://images2017.cnblogs.com/blog/1296884/201801/1296884-20180108161314894-1019011109.png 比较运算https://images2017.cnblogs.com/blog/1296884/201801/1296884-20180108161447004-894625074.png 赋值运算https://images2017.cnblogs.com/blog/1296884/201801/1296884-20180108161703379-1489017417.png 逻辑运算https://images2017.cnblogs.com/blog/1296884/201801/1296884-20180108161741394-1837061851.png 成员运算https://images2017.cnblogs.com/blog/1296884/201801/1296884-20180108161829426-1152133000.png 基本数据类型所有对象所具备的方法都保存在类中。对象和类的关系，举个例子：哺乳动物是类；此类下有两个对象，一个为狗、一个为猫。哺乳动物有较多的属性和方法，属性如有耳朵、有嘴巴；方法如叫、跑。那么我们在定义具体的方法的时候只需针对哺乳动物这个类进行定义即可，然后它之下的对象便自动带有了具体的属性和方法，即猫和狗虽然没有定义，但是有耳朵、嘴巴，还会跑和叫。 数字int（整型） 在32位机器上，整数的位数为32位，取值范围为-231～231-1，即-2147483648～2147483647 在64位系统上，整数的位数为64位，取值范围为-263～263-1，即-9223372036854775808～9223372036854775807 布尔值boolean 真或假；1或0 字符串string 字符串常用功能： 移除空白 分割 长度 索引 切片 列表创建列表 name_list=[&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] or name_list=list[&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;] 基本操作： 索引 切片 追加 删除 长度 切片 循环 包含 元组元组的创建: ages = (11, 22, 33, 44, 55) or ages = tuple((11, 22, 33, 44, 55)) 基本操作： 索引 切片 循环 长度 包含 字典（无序）字典的创建： person = {&quot;name&quot;: &quot;mr.wu&quot;, &apos;age&apos;: 18} or person = dict({&quot;name&quot;: &quot;mr.wu&quot;, &apos;age&apos;: 18}) 常用操作： 索引 新增 删除 键、值、键值对 循环 长度 set（集合）set是一个无序且不重复的集合。 其他for循环用户按照顺序循环可迭代对象中的内容， PS：break、continue li = [11,22,33,44] for item in li: print item enumrate为可迭代的对象添加序号 li = [11,22,33] for k,v in enumerate(li, 1): print(k,v) range和xrange指定范围，生成指定的数字。python3.0仅剩余range方法。 print range(1, 10) # 结果：[1, 2, 3, 4, 5, 6, 7, 8, 9] print range(1, 10, 2) # 结果：[1, 3, 5, 7, 9] print range(30, 0, -2) # 结果：[30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python入门]]></title>
    <url>%2F2018%2F11%2F10%2Fpython%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[第一句python代码在任意文件夹下创建 z1.py 文件（文件路径使用英文，如：“E:\work\python\usr”），内容如下： print(&quot;hello world&quot;) 执行z1.py，即在cmd命令行中，输入 python E:\work\python\usr\z1.py python的内部执行过程如下： https://images2017.cnblogs.com/blog/1296884/201801/1296884-20180103142448659-76768380.png 内容编码python解释器在加载 .py 文件中的代码时，会对内容进行编码（默认ascill） ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2**8 = 256，所以，ASCII码最多只能表示 256 个符号。 显然ASCII码无法将世界上的各种文字和符号全部表示，所以，就需要新出一种可以代表所有字符和符号的编码，即：Unicode。 UTF-8，是对Unicode编码的压缩和优化。 在使用python时，应该显示的告诉python解释器，用什么编码来执行源代码，即：加上头文件 #!/usr/bin/env python # -*- coding: utf-8 -*- print &quot;你好，世界&quot; 注释 单行注释 #内容 多行注释 “””内容””” 导入库的使用Python有大量的模块，从而使得开发Python程序非常简洁。类库有包括三中： Python内部提供的模块 业内开源的模块 程序员自己开发的模块 #!/usr/bin/env python # -*- coding: utf-8 -*- import (ku name) pyc文件执行Python代码时，如果导入了其他的 .py 文件，那么，执行过程中会自动生成一个与其同名的 .pyc 文件，该文件就是Python解释器编译之后产生的字节码。 ps：代码经过编译可以产生字节码；字节码通过反编译也可以得到代码。 变量声明变量#!/usr/bin/env python # -*- coding: utf-8 -*- name = &quot;zaoyufeifei&quot; age = 22 上述代码声明了两个变量，变量名为： name，变量name的值为：”zaoyufeifei”；age,变量age的值为22 变量的作用：昵称，其代指内存里某个地址中保存的内容 https://images2017.cnblogs.com/blog/1296884/201801/1296884-20180105090432159-699593039.png 变量定义的规则： 变量名只能是 字母、数字或下划线的任意组合 变量名的第一个字符不能是数字 以下关键字不能声明为变量名:[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’] 变量赋值#!/usr/bin/env python # -*- coding: utf-8 -*- name1 = &quot;zaoyu&quot; name2 = &quot;feifei&quot; https://images2017.cnblogs.com/blog/1296884/201801/1296884-20180105090737299-2021506625.png 输入#!/usr/bin/env python # -*- coding: utf-8 -*- # 将用户输入的内容赋值给 name 变量 name = raw_input(&quot;请输入用户名：&quot;) # 打印输入的内容 print name 输入密码时，如果想要不可见，需要利用getpass 模块中的 getpass方法，即： #!/usr/bin/env python # -*- coding: utf-8 -*- import getpass # 将用户输入的内容赋值给 name 变量 pwd = getpass.getpass(&quot;请输入密码：&quot;) # 打印输入的内容 print pwd 流程控制和缩进用户登录验证#!/usr/bin/env python # -*- coding: encoding -*- # 提示输入用户名和密码 # 验证用户名和密码 # 如果错误，则输出用户名或密码错误 # 如果成功，则输出 欢迎，XXX! import getpass name = raw_input(&apos;请输入用户名：&apos;) pwd = getpass.getpass(&apos;请输入密码：&apos;) if name == &quot;zaoyu&quot; and pwd == &quot;cmd&quot;: print &quot;欢迎，zaoyu！&quot; else: print &quot;用户名和密码错误&quot; 根据用户内容输出其权限# 根据用户输入内容打印其权限 # alex --&gt; 超级管理员 # eric --&gt; 普通管理员 # tony,rain --&gt; 业务主管 # 其他 --&gt; 普通用户 name = raw_input(&apos;请输入用户名：&apos;) if name == &quot;zao&quot;： print &quot;超级管理员&quot; elif name == &quot;yu&quot;: print &quot;普通管理员&quot; elif name == &quot;fei&quot; or name == &quot;dafei&quot;: print &quot;业务主管&quot; else: print &quot;普通用户&quot; while循环基本循环while 条件: # 循环体 # 如果条件为真，那么循环体则执行 # 如果条件为假，那么循环体不执行 break：用于退出所有循环while True: print &quot;123&quot; break print &quot;456&quot; continue：跳出本次循环，继续下次循环while True: print &quot;123&quot; continue print &quot;456&quot;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九届上海国际图书馆论坛]]></title>
    <url>%2F2018%2F10%2F18%2F%E7%AC%AC%E4%B9%9D%E5%B1%8A%E5%9B%BD%E9%99%85%E5%9B%BE%E4%B9%A6%E9%A6%86%E4%BC%9A%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[自2016年就提出，到2020年要建成智慧图书馆，智慧、包容、互联的转型阶段，智慧时代铺面而来，也正是面向全体社会化群体的。 主题：图书馆，变革的驱动器IFLA国际图联主席格洛莉亚致辞，战略规划包括三个内容： 社会图书馆学，即图书馆面向社会不同阶层、不同维度所发挥的作用 信息和知识，信息到知识在人脑中的逐步变革 文化遗产和能力构建 智慧与包容：重塑公共图书馆新愿景上海图书馆陈超馆长发言，社会包容是图书馆的核心价值观，图书馆应如何顺应智慧时代。 艺术作品和音乐等都在人工智能时代变得可以创作，即AI带来了智慧时代，信息化新阶段：从互联网+到AI+；AI可以为图书馆赋能，图书馆的服务、业务和管理会越来越智慧。AI不会替代图书馆员，不懂AI得图书馆员会被替代。 如今“弱人工智能”已经让图书馆有了基于ASRS的自动化立体书库、智能分拣系统、智能书架、自助借还系统等。未来，如果有所谓的“强人工智能”，那么总有一天图书馆将不再需要馆员做编目，智慧时代，图书馆将可能拥有真正的知识管理能力————分类编目和计算机的出现让图书馆能够比较高效的管理书籍，大数据、大容量存储、高强的计算力和AI技术以及未来将不断出现的新的信息与智能技术将使图书馆有能力直接管理知识。 判断一个职业是否能被人工智能代替，国际上常用的方法是从三个维度进行测量。第一个维度：行业所需要的社交智慧；第二个维度：所需要的创造力；第三个维度：需要的感知和操作能力。 与AI竞争，安全的工作符合以下特点：有非常高的创意性和抽象性思维；需要高度社交智慧和谈判技巧；需要关心和与人沟通能力。 除了要充分利用AI，公共图书馆还要帮助人类应对AI带来的挑战，通过阅读提升人们的文化素养，科学素养和艺术素养，旨在培育和提升人类的创造力。科学素养指科学、技术、工程和数学。艺术素养指美育、创意和创新能力。遵循“开放包容、平等包容、普惠包容、多元包容”的理念。]]></content>
      <categories>
        <category>会议记录</category>
      </categories>
      <tags>
        <tag>图书馆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序——页面跳转及传参]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%BE%AE%E4%BF%A1%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%8F%8A%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[小程序页面跳转微信小程序的页面跳转依然是以传统的请求转发和请求重定向为主，tabbar的存在，有TAB页面的跳转。为了微信小程序的简介方便，规定页面路径只能是十层，应尽量避免过多的交互方式。 1.wx.navigateTo(OBJECT)保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。 wx.navigateTo({ url: &apos;test?id=1&apos; }) url即目标页面，保证是非tabbar的页面的路径。路径后可以带参数，参数和路径之间用?=连接，不同参数用&amp;分开，如’path?key=value&amp;key2=value2’。需要获取页面A的参数，代入页面B中进行操作。在生命周期函数中获取option.id并转成实体，进行操作和赋值。 Page({ onLoad: function(option){ console.log(option.id) } }) 2.wx.redirectTo(OBJECT)关闭当前页面，跳转到应用内的某个页面。 wx.redirectTo({ url: &apos;test?id=1&apos; }) 3.wx.navigateBack(OBJECT)关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages()) 获取当前的页面栈，决定需要返回几层。页面的跳转存储逻辑实际是一个栈队列，先入后出的形式，即逐层进入，如果返回会进入的页面先返回，因此wx.navigateBack()中转递的参数默认值为1，即退后一个页面，可以修改数值，进行多层的返回。 // 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码 // 此处是A页面 wx.navigateTo({ url: &apos;B?id=1&apos; }) // 此处是B页面 wx.navigateTo({ url: &apos;C?id=1&apos; }) // 在C页面内 navigateBack，将返回A页面 wx.navigateBack({ delta: 2 }) 4.wx.switchTab(OBJECT)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面，路径只允许写在app.json中tabbar配置的页面。 wx.switchTab({ url: &apos;/index&apos; }) tip: wx.navigateTo 和 wx.redirectTo 不允许跳转到 tabbar 页面，只能用 wx.switchTab 跳转到 tabbar 页面 5.wx.reLaunch(OBJECT)关闭所有页面，打开到应用内的某个页面。 wx.reLaunch({ url: &apos;test?id=1&apos; })]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发入门]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[报名参加了上海图书馆组织的开放数据竞赛，目标就是由上图和其他机构提供的数据更好的利用。提供的大多数据都以结构化的关联数据形式组织，考虑到刚刚接触实践开发，且没有完整的开发团队，因此选择微信小程序的一个数据应用模式。 小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。对于开发者而言，小程序开发门槛相对较低，难度不及APP，能够满足简单的基础应用，适合生活服务类线下商铺以及非刚需低频应用的转换。小程序能够实现消息通知、线下扫码、公众号关联等七大功能。其中，通过公众号关联，用户可以实现公众号与小程序之间相互跳转。 小程序基本概念1.申请账号点击 https://mp.weixin.qq.com/wxopen/waregister?action=step1 根据指引填写信息和提交相应的资料，就可以拥有自己的小程序帐号。登录主界面即可以看到自己的AppID，在开发项目的时候需要绑定，才可以执行某些操作。 2.下载开发工具微信小程序开发工具已经很完善了，持续保持更新。有win32、64和mac版本。登录之后，窗口包括模拟器、编辑器和调试器三部分内容。 3.配置结构在建立项目的时候，可以选择快速模板，从目录结构可以看到小程序的配置内容。 app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。1.pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。2.window字段 —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。 小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。 网页编程还是基于HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。其中，从名字来看，小程序与之对应，功能一致，而且很多语法都基本类似。其中 WXML 充当的就是类似 HTML 的角色，由标签和属性共同组成页面的内容布局。WXSS相当于CSS的功能，可以更改内容的样式。JS即JAVASCRIPT语言，实现逻辑交互功能。 4.基础开发在了解了HTML、CSS和JAVASCRIPT和小程序开发配置结构的基础上，就可以开发自己的第一个小程序了。基础的学习内容可以在W3C中学习了解，上手也会较为轻松。http://www.w3school.com.cn/h.asp]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链微解读]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[BLOCKCHAIN TECHNOLOGY，区块链技术。 1.区块链来源 2008年10月，在密码朋克社区论坛中，中本聪发表了一篇名为《比特币：一种点对点式的电子现金系统》的白皮书，以类似论文的格式提出了一种新的模式的电子现金系统。中本聪真实身份未知，据信持有约一百万个比特币。从发表论文以来，中本聪的真实身份长期不为外界所知，维基解密创始人朱利安•阿桑奇（Julian Assange）宣称中本聪是一位密码朋克（Cypherpunk）。另外，有人称“中本聪是一名无政府主义者，他的初衷并不希望数字加密货币被某国政府或中央银行控制，而是希望其成为全球自由流动、不受政府监管和控制的货币。” 2009年1月3日，他开发出首个实现了比特币算法的客户端程序并进行了首次“采矿”（mining），获得了第一批的50个比特币。这也标志着比特币金融体系的正式诞生。 2010年12月5日，在维基解密泄露美国外交电报事件期间，比特币社区呼吁维基解密接受比特币捐款以打破金融封锁。中本表示坚决反对，认为比特币还在摇篮中，禁不起冲突和争议。七天后的12月12日，他在比特币论坛中发表了最后一篇文章，提及了最新版本软件中的一些小问题，随后不再露面，电子邮件通讯也逐渐终止。 2.区块链定义 区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。所谓共识机制是区块链系统中实现不同节点之间建立信任、获取权益的数学算法。从文章最初的题目可以看到，区块链的核心本质是点对点和电子现金系统。现如今仍然处于信息互联网，而区块链的提出是一场社会变革，会使得信息互联网转向价值互联网。 互联网起源于上个世纪的美国。1950年，通信研究者认识到需要允许在不同的计算机用户和通信网络之间进行常规的通信，这促进了分布式网络、包交换、排队理论的研究。 1969年，ARPA网把美国四所大学连接了起来，被视为互联网的肇始。 1974年，ARPA的罗伯特•卡恩和斯坦福大学的温登•泽夫提出TCP/IP协议，定义了计算机网络之间传送报文的方法。 1983年，ARPA网将其网络核心协议由NCP改为TCP/IP协议。这一协议标准成为日后互联网通信协议的最基础的标准。 随着互联网的商业化，其在通信、信息检索、客户服务等方面的巨大潜力被挖掘出来，使得互联网有了质的飞跃，并最终走向全球化。 1990年，互联网向广大公众正式开放。 1991年，蒂姆•博纳斯里在瑞士欧洲核子研究组织创建了HTML、HTTP和最初几个网页，之后两年，开始宣传其万维网项目。 此后经过约10年，互联网成功地将大多数存量计算机纳入到网络中，同时互联网上出现了越来越多的商业应用。 概而言之，互联网的飞速发展要归功于互联网没有中心化控制，以及互联网协议非私有的特点，使得互联网迅速传递到世界的每一个角落，及大地降低了世界范围内的信息传递成本。 随着传统互联网的快速发展，如何管理大量交易数据，保障交易安全以及如何准确进行身份验证，正确地使用电子签名，保障数据的真实性、完整性和线上交易的高效性等，是当前互联网企业面临的重大问题。 区块链的诞生，彻底改变了互联网的系统架构模式。 区块链是在互联网中创造一种机制，这种体系在人们不能互相信任的前提下，还可以从事价值交换的活动，依托其非中心化、去信任化、集体维护、可信数据库等四大优势，从根本上改变现代市场交易的信用体系，降低欺诈风险。 TCP/IP协议构建了互联网点对点传递的基础，而区块链则能实现价值的点对点传递，真正实现从传统互联网到价值互联网的转变。 区块链对互联网第二个层次的突破是产业互联网或称工业互联网。现有的互联网是基于人与人之间、人与社会之间的通信关系。区块链与物联网、车联网等技术相结合，能够建立社会与社会、物与物之间的互联互通关系，区块链在这当中可以起到非常关键的设备管理之功能。 区块链对互联网第三个层次的突破是加密互联网。现有的互联网是完全公开透明的，互联网可以盗取人们几乎所有的数据，这一问题在将来可能达到人们无法接受的程度。而区块链上的加密通信可以有力地保障用户隐私，保障个人数据不被互联网公司无偿获取。 区块链对互联网第四个层次的突破是分布式与非分布式的互联网。区块链结合了分布式网络的技术，能够去除很多中心或中介。虽然不能彻底去掉中心，但是依然能够在很大程度上解构现有的业态。未来信息社会的非中心化结构，将会与工业社会的中心化结构截然不同。 可以说，区块链不仅仅孕育新的商业模式，也会给经济社会带来巨大变化，蕴含无限的可能。区块链所指向的未来不只是技术层面上更好的网络系统，还包括了非中心化的全新社会架构。对于未来的非中心化的新时代而言，区块链将是非常重要的基础设施。 总的来说，区块链使得电子现金的交易持有了匿名性，因此最早应用于黑市交易，也就是洗钱。 3.一些概念的含义点对点的交易传统的系统架构是C/S结构，客户端请求服务器，继而服务器根据客户端的请求返回相应的内容。而区块链本身是无服务器的，比特币也是相对应的一般等价物，无服务器即各个节点都会存储相同的数据，数据冗余很大，不同的节点通过指针链表的形式彼此链接，类似数据结构中的链表结构，一个节点分为两部分，一部分存储数据，另一部分负责指向相关节点。 发生交易时，节点会将交易过程广播出去，所有节点都会进行记录，也无需中介干预，通过一定的加密算法即可完成交易过程。保证了不可篡改的可信性，比特币的价位，也像是超主权货币的含义，就像欧元一样，统一全球货币。 共识机制共识机制：所谓“共识机制”，是通过特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。再通俗一点来讲，如果中国一名微博大V、美国一名虚拟币玩家、一名非洲留学生和一名欧洲旅行者互不相识，但他们都一致认为你是个好人，那么基本上就可以断定你这人还不坏。 非对称加密非对称加密：对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。 零知识证明零知识证明：它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。大量事实证明，零知识证明在密码学中非常有用。如果能够将零知识证明用于验证，将可以有效解决许多问题。 交易产生的账户与传统的交易过程区别的还有一点，就是比特币每次交易会产生一个新的账户，即A账户原先有50个币，预计向B账户交易20个币，那么发起交易过程后，A账户会将50个币全部转出，向B账户转入20个币，新建一个账户C放入剩余的30个币，即产生一个新的节点，原先的A账户会删掉，这样做的好处即每人会有一个账户，无需管理多余停滞的账户。 4.区块链带来的变革人工智能改变生产力；大数据改变生产资料；区块链改变的是生产关系。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[July]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%B8%83%E6%9C%88%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[SPARQL查询语言]]></title>
    <url>%2F2018%2F10%2F18%2Fsparql%2F</url>
    <content type="text"><![CDATA[SPARQL的查询是基于结构化知识的，变无序数据为有序知识，让计算机理解Web信息，即语义Web。现如今，语义网适用于各个领域，包括语义出版、语义知识库等。SPARQL是针对以RDF框架进行存储的知识库进行检索的SQL语句，因此有一定SQL基础的话，学习会很容易。 什么是语义网？ 语义网是一种使用可以被计算机理解的方式描述事物的网络。林俊杰是著名歌手。小酒窝是林俊杰唱的。林俊杰也是演员。像这样的句子可以被人类理解。但是如何能够被计算机理解呢？ 陈述是由语法规则构建的。一门语言的语法定义了构建该语言的陈述所需的规则。 这就是语义网的本质所在 - 以计算机应用程序可以理解的方式描述事物。 语义网和网页之间的链接没有关系。 语义网描述的是事物之间的关系（比方说 A 是 B 的一部分，而 Y 是 Z 的成员）以及事物的属性（例如尺寸、重量、使用期限和价格等等）。 资源描述框架 RDF(资源描述框架，Resource Description Framework)是一种用于描述网络上的信息和资源的的标记语言。 将信息至于 RDF 文件之中，这样的话，这些信息就有可能被计算机程序（”web spiders”）从网络中搜索、发现、摄取、筛选、分析和处理。 语义网使用 RDF 来描述网络资源。 如果希望学习更多关于 RDF 的知识，请参考 http://www.w3school.com.cn/rdf/index.asp 。 概述当信息被表示为RDF后，出于推理和应用开发的需要，我们需要能够存取其中的部分。也就是需要叫做SPARQL的语言，它能够让我们通过选择、抽取等方式很容易地从被表示为RDF的知识中获得特定的部分。SPARQL是专为RDF设计的，适合并依赖于万维网上的各种技术。 SPARQL基础设施： 想要执行一条SPARQL查询，就需要一个能执行查询的软件。能做到这一点的最常用的软件叫做三元组存储库。本质上，一个三元组存储库就是一个RDF的数据库。在网上可以下载到很多三元组存储库。在SPARQL的相关规范中，三元组存储库也称为图存储库。 在查询一个三元组存储库之前，需要先向其中填充RDF数据。大部分三元组存储库都提供批量上传的选项。也有一种称为SPARQL更新的机制，提供了一系列向三元组存储库中插入、加载及删除RDF的选项。 匹配模式###简单的查询 Data: &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; &quot;SPARQL Tutorial&quot; . Query: SELECT ?title WHERE { &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title . } Result:Title SPARQL Tutorial 例如，要在这段数据中做一个查询。找到这本书的书名。 在SPARQL中，我们可以将三元组中的任何一个元素替换为一个变量。变量的首字符是一个？（问号）。要引入一个变量表示所要查询的位置。 三元组存储库将接收这个图模式并尝试去找到能够匹配这个模式的那些三元组集合。因此找到了主谓一致的三元组。并返回它的宾语。 如这个例子中，Data中有一个三元组，在构建查询的时候，利用select关键词构造主语和谓语，宾语作为变量返回，系统会根据查询式构造一个三元组图模式与RDF库中的所有三元组进行匹配，将满足条件的结果返回。 多个匹配Data: @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; . _:a foaf:name &quot;Johnny Lee Outlaw&quot; . _:a foaf:mbox &lt;mailto:jlow@example.com&gt; . _:b foaf:name &quot;Peter Goodguy&quot; . _:b foaf:mbox &lt;mailto:peter@example.org&gt; . _:c foaf:mbox &lt;mailto:carol@example.org&gt;. Query: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name ?mbox WHERE { ?x foaf:name ?name . ?x foaf:mbox ?mbox } 与turtle类似，PREFIX关键词指明各种各种URL的缩写。返回的结果中，每一格表示一个结果。 Data中的_:a _:b _:c是空白节点，没有具体意义，且字母不固定，只是用来区分不同的实体资源。 条件限制如果上述的简单查询不能满足查询需求，则需要对查询的结果进行一定的条件限制，常用的限制字段主要为：filter、optinal、union。 Filter：限制数字或字符串符合一定要求的结果。数值型数据类型（即整数型、小数）和日期/时间都支持小于、大于和等于运算。 Optional关键词告诉三元组存储库为特定的图模式返回结果——如果能找到。即对于待返回的查询而言，这个图模式未必要满足。 UNION关键词告诉三元组存储库返回那些仅匹配一个图模式或两个都匹配的结果。 通过例子来进行学习： Data： @prefix dc:&lt;http://purl.org/dc/elements/1.1/&gt; . @prefix : &lt;http://example.org/book/&gt; . @prefix ns: &lt;http://example.org/ns#&gt; . :book1 dc:title &quot;SPARQL Tutorial&quot; . :book1 ns:price 42 . :book2 dc:title &quot;The Semantic Web&quot; . :book2 ns:price 23 . Query: PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt; PREFIX ns: &lt;http://example.org/ns#&gt; SELECT ?title ?price WHERE { ?x ns:price ?price . FILTER (?price &lt; 30) ?x dc:title ?title . } 可以看到，filter字段通过对price的限制，筛选出了price小于30的所有实体，并返回title和price。 Data： @prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; . @prefix : &lt;http://example.org/book/&gt; . @prefix ns: &lt;http://example.org/ns#&gt; . :book1 dc:title &quot;SPARQL Tutorial&quot; . :book1 ns:price 42 . :book2 dc:title &quot;The Semantic Web&quot; . :book2 ns:price 23 . Query1: PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt; SELECT ?title WHERE { ?x dc:title ?title FILTER regex(?title, &quot;^SPARQL&quot;) } Query2: PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt; SELECT ?title WHERE { ?x dc:title ?title FILTER regex(?title, &quot;web&quot;, &quot;i&quot; ) } filter字段不仅可以对数字进行限制，还可以利用正则表达式进行对字符串的限制，filter加上regex，括号中表明变量?title，字符串str，即过滤出变量包含str的实体，str前面加^即表示以str开头，否则默认为包含有。 OPTIONAL表示有则返回，没有则返回空。UNION表示满足任一即返回，相当于布尔逻辑中的OR。 组织结果集我们想要查询结果以一种特定的方式返回：分组的、计数的或排序的。SPARQL支持一些函数来帮助我们组织结果集。 Order: put the solutions in order Distinct: ensure solutions in the sequence are unique Reduced: permit elimination of some non-unique solutions Offset: control where the solutions start from in the overall sequence of solutions Limit: restrict the number of solutions 在更大的数据集上，我们可能不知道有多少条结果，或者我们的查询会不会返回整个数据集。因此，一个好的做法就是限制一条查询能返回的答案的数量。就是LIMIT关键词。 Query: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name WHERE { ?x foaf:name ?name } LIMIT 20 //限制返回结果为20条 Data: @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; . _:x foaf:name &quot;Alice&quot; . _:x foaf:mbox &lt;mailto:alice@example.com&gt; . _:y foaf:name &quot;Alice&quot; . _:y foaf:mbox &lt;mailto:asmith@example.com&gt; . _:z foaf:name &quot;Alice&quot; . _:z foaf:mbox &lt;mailto:alice.smith@example.com&gt; . Query: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT ?name WHERE { ?x foaf:name ?name } Query: PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt; SELECT DISTINCT ?name WHERE { ?x foaf:name ?name } DISTINCT关键字，可以保证结果唯一，REDUCED会对重复的结果进行适当的减少，不同的情况用不同的限制。 在SPARQL中，使用ORDER BY关键词来对返回的结果集排序。例如，按公寓所含卧室数量进行排序。 DESC关键词指明了按降序排列。ASC指的是升序。 此外，字符串得排序是根据字典序。 查询方式SPARQL有四种查询形式。 SELECT：在查询匹配模式中，返回所有的，或者部分子集。 CONSTRUCT：通过取代三元组中的变量，返回一个新RDF图模式。 ASK：返回一个布尔值，显示是否有匹配项。 DESCRIBE：返回一个表述资源的RDF图模式。 使用方式 sparql的使用方式主要为两种，一种是网页知识库提供的查询端口，例如wikidata中提供的query service，在不同的知识库中有不同的词表属性，对不同的实体和属性有不同的ID号，需要另外学习，但是基本的语法基本一样，看几个例子便可以使用；第二种是利用Jena包编写代码进行自定义查询，当然还有很多工具平台也提供了sparql端口，例如D2RQ，但是它的底层实现也是基于Jena实现对于RDF的解析和可视化。]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>语义网 sparql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python反射机制]]></title>
    <url>%2F2018%2F10%2F18%2Fpython%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.前言一个模块有变量、方法，如果我们在另一个模块中调用的时候会用到import。如果一开始不确定要导入的模块，如何通过手动输入模块名来实现功能呢？反射解决的就是这个问题，通过字符串的形式，导入模块；通过字符串的形式，去模块中寻找指定函数（或变量）并执行。 #test.py: def f1(): print(&quot;F1&quot;) def f2(): print(&quot;F2&quot;) i = 5 使用import调用test中的方法和变量 import test as fun fun.f1() fun.f2() print(fun.i) 使用import()方法可以实现接受动态输入模块名，随时动态的导入模块。(import可以导入字符串形式的模块) inp = input(&quot;请输入要导入的模块名&quot;) #获取输入的模块名，得到为字符串 fun = __import__(inp) #利用__import__函数获取字符串格式的模块 fun.f1() #执行f1方法 当然，针对函数也可以进行动态调用，利用getattr(模块名，函数名) inp = input(&quot;请输入要导入的模块名&quot;) fun = __import__(inp) inp_fun = input(&quot;请输入要执行的函数名&quot;) f = getattr(fun,inp_fun) f() 2.反射机制除了上面介绍的导入模块，调用函数和变量外，还可以利用字符串形式操作模块、对象中的成员，包括查找、获取、删除、添加等。 1. getattr(object, name) 说明：导入模块并获取方法 2. hasattr(object, name) 说明：判断对象object是否包含名为name的特性（hasattr是通过调用getattr(ojbect, name)是否抛出异常来实现的） 3. setattr(object, name, value) 这是相对应的getattr()。参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。例如,setattr(x,“foobar”,123)相当于x.foobar = 123。 4. delattr(object, name) 与setattr()相关的一组函数。参数是由一个对象(记住python中一切皆是对象)和一个字符串组成的。string参数必须是对象属性名之一。该函数删除该obj的一个由string指定的属性。delattr(x, &apos;foobar&apos;)=del x.foobar 3.Web实例考虑浏览器的页面跳转问题，根据用户输入的不同url，返回不同的页面内容，也就是一个url路由器功能，相同的思路是web框架的核心部件之一。 ####首先是一个commons模块#### def login(): print(“这是一个登陆页面！”) def logout(): print(&quot;这是一个退出页面！&quot;) def home(): print(&quot;这是网站主页面！&quot;) ####其次是一个visit模块#### import commons def run(): inp = input(&quot;请输入您想访问页面的url： &quot;).strip() if inp == &quot;login&quot;: commons.login() elif inp == &quot;logout&quot;: commons.logout() elif inp == &quot;home&quot;: commons.home() else: print(&quot;404&quot;) if __name__ == &apos;__main__&apos;: run() 这就实现了一个简单的web路由功能，根据不同的url，执行不同的函数，对应到浏览器就是返回不同的页面内容。这仅仅是三个函数功能，那么如果有几百个几千个不同的方法，是不可能全部if-else进行编写的，因此可以利用getattr()方法获取函数名，在继而判断是否存在此函数。 import commons def run(): inp = input(&quot;请输入您想访问页面的url： &quot;).strip() if hasattr(commons,inp): func = getattr(commons,inp) func() else: print(&quot;404&quot;) if __name__ == &apos;__main__&apos;: run() 总结：反射即如何利用字符串执行不同的事件，比如导入模块，执行方法，查找变量，这些都是python的反射机制，是一种编程方法、设计模式，所以在java、c#中也有类似的功能实现，理解了运作模式和思路，实现都是比较好做的。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python 反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python入门练习题]]></title>
    <url>%2F2018%2F10%2F18%2Fpython1%2F</url>
    <content type="text"><![CDATA[###1、使用while循环输入 1 2 3 4 5 6 8 9 10 num = 1 while num&lt;=10: if num ==7: num += 1 continue print(num) num += 1 ###2、求1-100的所有数的和 num = 1 sum = 0 while num&lt;=100: sum += num num += 1 print(sum) ###3、输出 1-100 内的所有奇数 num = 1 while num&lt;=100: if num%2 ==0: num += 1 continue print(num) num +=1 ###4、求1-2+3-4+5 … 99的所有数的和 num = 1 sum = 0 while num&lt;=100: if num%2 ==0: sum += num else: sum -= num num +=1 print(sum) ###5.用户登陆（三次机会重试） count = 0 while True: usrname = input(“usrname&gt;&gt;&gt;”) password = input(“password&gt;&gt;&gt;”) if usrname == “zaoyufeifei” and password ==”123456”: print(“enter ok”) break else: print(“usrname or password false,please again”) count +=1 if count==3: print(“3 times over,you are false”) break continue]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法]]></title>
    <url>%2F2018%2F10%2F18%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.概述接触Hexo个人博客站点后，肯定得学习和了解Markdown的基础使用。Markdown正是使网络发布更加方便的语言。相比于HTML，它的种类很少，我认为Markdown并不是说要网络书写更加方便，因为HTML的结构和内容设计已经很方便了，Markdown抛却标签的内容，让作者的重点放在内容分析和处理上。而且便于之后内容的更改和解析。需要了解的是，Markdown中兼容HTML语法，因此有些标签和使用习惯可以代入使用。 2.区块元素段落和换行两个以上的空格即可实现段落换行，也就是&lt;br/&gt;标签的作用 标题可以使用###号来表示标题1-6，当然在markdown编辑器下，可以在insert中插入heading # H1 # ## H2 ## ### H3 ### #### H4 #### ##### H5 ##### ###### H6 ###### 区块引用用&gt;符号即可，例： 引用内容块 列表在markdown编辑器可以直接选择insert,有序和无序列表。与HTML类似。 代码区块在Markdown中使用代码块，可以用四个空格或是一个制表符表示。或者通过code直接插入代码块。 code内容 //需要注意的是在使用的时候，要使用双回车来隔开上一段文字内容 分割线分割线样式多样，使用简单，例如： * * * *** ***** - - - --------------------------------------- 3.区段元素链接在Markdown编辑器中找到链接的按钮或是Ctrl+L，可以设置链接网址。也可以通过行内链接来表示。 This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. [ ]中表示链接的点击位置，（ ）内表示链接网址，“ ”内是链接的名称，即鼠标放上去显示的内容。 强调用*号括起来表示弱强调，双**号括起来表示强掉 当然也可以用于标记代码段 图片![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) ！ 开头，表示图片内容，[ ]号内容表示替代文字；（ ）表示图片链接。markdown提供UI窗口执行插入图片的操作。 编辑器Windows 平台-Markdown 免费编辑器 Linux 平台-MarkdownPad -MarkPad ###-Mac 平台### -ReText 在线编辑器-Mou 浏览器插件-Markable.in -Dillinger.io -MaDe (Chrome) -Sublime Text 2 -MarkdownEditing]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene实现索引和查询]]></title>
    <url>%2F2018%2F10%2F18%2FLucene%2F</url>
    <content type="text"><![CDATA[1.引言随着万维网的发展和大数据时代的到来，每天都有大量的数字化信息在生产、存储、传递和转化，如何从大量的信息中以一定的方式找到满足自己需求的信息，使之有序化并加以利用成为一大难题。全文检索技术是现如今最普遍的信息查询应用，生活中利用搜索引擎，在博客论坛中查找信息，这些搜索的核心原理就是本文要实现的全文检索技术。随着文档信息数字化的实现，将信息有效存储并及时准确的提取是每一个公司、企业和单位要做好的基础。针对英文的全文检索已经有很多成熟的理论和方法，开放源代码的全文检索引擎Lucene 是Apache 软件基金会Jakarta 项目组的一个子项目，它的目的是为软件开发人员提供一个简单易用的工具包，方便在目标系统中实现全文检索的功能。Lucene不支持中文，但是目前已有很多开源的中文分词器可以对中文内容进行索引，本文在研究Lucene核心原理的基础上，分别实现了对中英文网页的爬取和检索。 2.Lucene介绍2.1 lucene 简介Lucene是一个用Java写的全文检索引擎工具包，实现构造了索引和搜索两大核心功能，并且两者相互独立，这使得开发人员可以方便扩展，Lucene提供了丰富的API , 可以与存储在索引中的信息方便的交互。需要说明的是它并不是一个完整的全文检索应用, 而是为应用程序提供索引和搜索功能。即若想让Lucene 真正起作用, 还需在其基础上做一些必要的二次开发。 Lucene的结构设计与数据库的设计较为相似，但Lucene的索引与数据库有着极大的不同。数据库和Lucene建立索引都是为了查找方便，但是数据库仅仅针对部分字段进行建立，且需要把数据转化为格式化信息，并予以保存。而全文检索是将全部信息按照一定方式进行索引。两种检索的不同和相似如表1-1所示。 表1-1：数据库检索与Lucene检索对比 2.2 lucene总体结构Lucene软件包的发布形式是一个JAR文件，版本更新较快且版本差距较大，本文使用的是5.3.1的版本，主要使用的子包如表1-2所示。 2.3 lucene架构设计Lucene功能非常强大，但从根本上来说，主要包括两块：一是从文本内容切分词后索引入库；二是根据查询条件返回结果，即建立索引和进行查询两部分。 如图1-1所示，本文抛出外部接口以及信息来源，重点对网页爬取的文本内容进行索引和查询 。 3 JDK的安装和环境变量的配置1.jdk的下载：在oracle官网下载符合系统版本的压缩包，网址如下。点击安装，根据提示进行安装，在安装过程中会提示是否安装jre，点击是。 http://www.oracle.com/technetwork/java/javase/downloads/index.html 2.设置环境变量：（1）右键计算机=》属性=》高级系统设置=》环境变量=》系统变量=》新建=》JAVA_HOME:安装路径 （2）Path中新增=》%JAVA_HOME%\bin 3.测试是否成功： 开始=》运行=》CMD 回车 在弹出的 DOS 窗口内 输入：java -version 会出现版本信息， 输入： javac出现 javac 的用法信息 出现如图2-1所示为成功。 4 编写Java代码实现对网页内容的获取因为Lucene针对不同语言要使用不同的分词器，英文使用标准分词器，中文选择使用smartcn分词器。在获取网页的时候，先获取网页存为html文件，在html中由于标签 的干扰，会对检索效果产生影响，因此需要对html标签进行剔除，并将文本内容转为txt文件进行保存。中英文除了分词器不同，其他基本一致，因此之后的代码和实验结果演 示会选择任一。本文选取五十篇中文故事和英文故事的网页为例。 具体代码设计如下图：Url2Html.java将输入网址的网页转存为html文件,Html2Txt.java文件实现html文档标签的去除，转存为txt文档。具体代码如图3-1和3-2。 public void way(String filePath,String url) throws Exception{ File dest = new File(filePath);//建立文件 InputStream is;//接收字节输入流 FileOutputStream fos = new FileOutputStream(dest);//字节输出流 URL wangzhi = new URL(url);//设定网址URL is = wangzhi.openStream(); BufferedInputStream bis = new BufferedInputStream(is);//为字节输入流加缓冲 BufferedOutputStream bos = new BufferedOutputStream(fos);//为字节输出流加缓冲 /* * 对字节进行读取 */ int length; byte[] bytes = new byte[1024*20]; while((length = bis.read(bytes, 0, bytes.length)) != -1){ fos.write(bytes, 0, length); } /* * 关闭缓冲流和输入输出流 */ bos.close(); fos.close(); bis.close(); is.close(); } public String getBody(String val){ String zyf = val.replaceAll(&quot;&lt;/?[^&gt;]+&gt;&quot;, &quot;&quot;); //剔出&lt;html&gt;的标签 return zyf; } public void writeTxt(String Str,String writePath) { File writename = new File(writePath); try { writename.createNewFile(); BufferedWriter out = new BufferedWriter(new FileWriter(writename)); out.write(Str); out.flush(); out.close(); } catch (IOException e) { e.printStackTrace(); } } 以童话故事《笨狼上学》的网页为例，文档路径设为”E:\work \lucene \test \data \html”和”E:\work\lucene\test\data\txt”，在每一次读取网页的时候需要设定的两个参数为文件命名filename和获取目标网址url。新建一个main函数，实现对两个方法的调用。具体实现如图3-3所示： public static void main(String[] args) { String filename = &quot;jingdizhi&quot;;//文件名字 String url = &quot;http://www.51test.net/show/8072125.html&quot;;//需要爬取的网页url String filePath = &quot;E:\\work\\lucene\\test\\data\\html\\&quot;+filename+&quot;.html&quot;;//写出html的文件路径+文件名 String writePath = &quot;E:\\work\\lucene\\test\\data\\txt\\&quot;+filename+&quot;.txt&quot;;//写出txt的文件路径+文件名 Url2Html url2html = new Url2Html(); try { url2html.way(filePath,url); } catch (Exception e) { e.printStackTrace(); } Html2Txt html2txt = new Html2Txt(); String read=html2txt.readfile(filePath);//读取html文件 String txt = html2txt.getBody(read);//去除html标签 System.out.println(txt); try { html2txt.writeTxt(txt,writePath); } catch (Exception e) { e.printStackTrace(); } } 执行程序后，分别在两个文件夹中建立”笨狼上学.html”和”笨狼上学.txt”。 5 建立索引索引和查询的基本原理如下： 建立索引：搜索引擎的索引其实就是实现“单词-文档矩阵”的具体数据结构。也是进行全文检索的第一步，lucene提供IndexWriter类进行索引的管理，主要包括add()、delete()、update()。还有对权值的设定，通过不同索引权值的设定，可以在搜索的时候根据相关性大小进行返回。 进行搜索：原本的直接搜索是针对文档进行顺序检索，在建立索引之后，可以通过对索引的查找以找到索引词在文档中出现的位置，然后返回索引项所对的文档中的位置和词。Lucene提供IndexSearcher类进行对文档的检索，检索形式主要分为两类，第一类是Term，针对单个词项的检索；第二类是Parser，可以自定义构造检索表达式，有较多的检索形式，具体的方法会在之后进行实现的演示。 5.1 实验环境本PC机采用windows 10x64系统，8G内存，256G固态硬盘。开发环境为Myeclipse 10，jdk版本为1.8。在实验过程中，因为部分语法的转变，若干Class采用1.6版本实现。 5.2 建立索引建立索引库就是往索引库添加一条条索引记录，Lucene为添加一条索引记录提供了接口，添加索引。 主要用到了“写索引器”、“文档”、“域”这3 个类。要建立索引，首先要构造一个Document 文档对象，确定Document的各个域，这类似于关系型数据库中表结构的建立，Document相当于表中的一个记录行，域相当于一行中的列，在Lucene 中针对不同域的属性和数据输出的需求，对域还可以选择不同的索引/存储字段规则，在本实验中，文件名fileName、文件路径fullPath和文本内容content作为Document 的域。 IndexWriter 负责接收新加入的文档，并写入索引库中。在创建“写索引器”IndexWriter 时需要指定所使用的语言分析器。建立索引分为两个类别，第一：不加权索引；第二：加权索引。 public Indexer(String indexDir)throws Exception{ Directory dir=FSDirectory.open(Paths.get(indexDir)); Analyzer analyzer=new StandardAnalyzer(); // 标准分词器 //SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer(); IndexWriterConfig iwc=new IndexWriterConfig(analyzer); writer=new IndexWriter(dir, iwc); } 设置索引字段，Store表示是否对索引内容存储：fileName和fullPath占用内存较少可以进行存储，以方便查询返回。 private Document getDocument(File f)throws Exception { Document doc=new Document(); doc.add(new TextField(&quot;contents&quot;, new FileReader(f))); doc.add(new TextField(&quot;fileName&quot;, f.getName(),Store.YES)); doc.add(new TextField(&quot;fullPath&quot;,f.getCanonicalPath(),Store.YES));//路径索引 return doc; } 执行主代码后结果如图：设计在索引某个文件的时候返回文件“索引文件：+文件路径”，且计算输出索引全部文件花费的时间。 5.3 对索引的删除和修改一般对数据库的操作包括CRUD（增加、删除、更改、查询），增加就是对索引项的选择和建立，查询作为较为核心的功能会在之后展开论述，这里主要记录一下在删除、更新索引时用到的方法。 删除分为两种类型，包括普通的删除和彻底删除，因为索引的删除影响到整个数据库，而且对于大型的系统而言，删除索引意味着对系统的底层进行更改，耗时耗力而且无法返回，前面索引的时候看到建立索引后生成若干小文件，当进行查找的时候会将各个文件进行合并然后查找。普通删除仅仅是对之前建立的索引做个简单的标记，致使无法进行查找返回。彻底删除则是对索引进行销毁，无法撤销。以删除索引项“id”为1的索引为例： 普通的删除(在合并前删除)： writer.deleteDocuments(new Term(“id”,”1”)); writer.commit(); 彻底的删除（在合并后删除）： writer.deleteDocuments(new Term(&quot;id&quot;,&quot;1&quot;)); writer.forceMergeDeletes(); // 强制删除 writer.commit(); 对索引的修改原理比较简单，就是在原有索引的基础上实现覆盖，实现代码跟上文的增加索引一样，在此不多做阐述。 5.4 对索引的加权Lucene默认按照相关度排序，Lucene对Field提供了一个可以设置的Boosting参数，这个参数用来表示记录的重要性，在满足搜索条件是，会优先考虑重要性高的记录，返回结果靠前，如果记录较多，权值低的记录会排到首页之后，因此，对索引的加权操作是影响返回结果满意度的重要因素，在实际设计信息系统的时候，应该有严格的权值计算公式，方便对Field权值的更改，更好的满足用户的需求。 例如搜索引擎将点击率高，链入链出的网页给定较高的权重，在返回的时候排到第一页。实现代码如图4-1所示，不加权和加权结果对比如图4-2所示。 TextField field = new TextField(&quot;fullPath&quot;, f.getCanonicalPath(), Store.YES); if(&quot;A GREAT GRIEF.txt&quot;.equals(f.getName())){ field.setBoost(2.0f);//对文件名为secondry story.txt的fullPath路径加权； } //默认权重为1.0，改为1.2即增加权重。 doc.add(field); 由图结果可以看出，不加权时，按照字典顺序排列返回，因此first在secondry之前，在对secondry命名的文件路径加权后，返回的时候顺序发生变化，实现对权重的测试。 6 进行查询Lucene 的检索接口主要由QueryParser、IndexSearcher、Hits这3 个类构成，QueryParser 是查询解析器，负责解析用户提交的查询关键字，在新建一个解析器时需要指定要解析的域和使用什么语言分析器，这里使用的语言分析器必须与索引库建立时使用的解析器相同，否则查询结果不正确。IndexSearcher是索引搜索器，在实例化IndexSearcher时需要指定索引库所在的目录，IndexSearcher有一个search 方法执行索引的检索，这个方法接受Query 作为参数，返回Hits，Hists 是一系列排好序的查询结果的集合，集合的元素是Document。通过Document的get 方法可以得到与这个文档对应文件的信息，比如：文件名、文件路径、文件内容等。 6.1 基本查询如图查询主要有两种方式，但是推荐使用第一种构造QueryParser表达式，它可以有灵活的组合方式，包括布尔逻辑表达、模糊匹配等，但是第二种Term只能针对词汇查询。 1.构造QueryParser查询式： QueryParser parser=new QueryParser(&quot;fullPath&quot;, analyzer); Query query=parser.parse(q); 2.对特定项的查询： Term t = new Term(&quot;fileName&quot;, q); Query query = new TermQuery(t); 查询结果如图5-1所示：以查询文件名fileName包含“大”为例。 6.2 模糊查询在构造QueryParser时，通过对词项q的修改可以实现精确匹配和模糊匹配。模糊匹配通过在“q”之后加“~”进行修改。如图5-2所示： 6.3 限定条件查询布尔逻辑查询和模糊查询只需要对查询词q进行更改，而限定条件查询需要对query表达式进行设定，主要分为以下几类： 分别为指定项范围搜索、指定数字范围、指定字符串开头和多条件查询，分别列出应用的查询，true参数指的：是否包含上限和下限在内。 指定项范围： TermRangeQuery query=new TermRangeQuery(&quot;desc&quot;, new BytesRef(&quot;b&quot;.getBytes()), new BytesRef(&quot;c&quot;.) 指定数字范围： NumericRangeQuery&lt;Integer&gt; query=NumericRangeQuery.newIntRange(&quot;id&quot;, 1, 2, true, true); 指定字符串开头： PrefixQuery query=new PrefixQuery(new Term(&quot;city&quot;,&quot;a&quot;)); 多条件查询： NumericRangeQuery&lt;Integer&gt;query1=NumericRangeQuery.newIntRange(&quot;id&quot;, 1, 2, true, true); PrefixQuery query2=new PrefixQuery(new Term(&quot;city&quot;,&quot;a&quot;)); BooleanQuery.Builder booleanQuery=new BooleanQuery.Builder(); booleanQuery.add(query1,BooleanClause.Occur.MUST); booleanQuery.add(query2,BooleanClause.Occur.MUST); 6.4 高亮查询在百度、谷歌等搜索引擎中，进行查询时，返回的网页包含查询关键字的时候会显示为红色，且进行摘要显示，即对包含关键字的部分内容进行截取并返回。高亮查询即为实现对关键字的样式更改，本实验在myeclipse中进行，返回结果并不会有样式的改变，只会对返回内容的关键字添加html标签，如果显示到网页即产生样式的变化。 高亮的设置代码如图5-3所示，结果如图5-4所示，会对南京匹配词添加和标签，显示到网页上为加粗和变红。 QueryScorer scorer=new QueryScorer(query); Fragmenter fragmenter=new SimpleSpanFragmenter(scorer); SimpleHTMLFormatter simpleHTMLFormatter=new SimpleHTMLFormatter(&quot;&lt;b&gt;&lt;font color=&apos;red&apos;&gt;&quot;,&quot;&lt;/font&gt;&lt;/b&gt;&quot;); Highlighter highlighter=new Highlighter(simpleHTMLFormatter, scorer); highlighter.setTextFragmenter(fragmenter); 7 实验过程中遇到的问题和不足LUCENE版本更新较快，在JDK版本、ECLIPSE版本和LUCENE版本之间需要一个良好的衔接，否则会造成很多的不兼容，在调试版本以及JDK1.6和JDK1.8的选择上出现很多困难，比如网页抓取中的APPEND方法在1.8版本已经删除，不能使用。但是对文档路劲的读取FSDIRECTORY.OPEN()则需要JDK1.8才支持。 本实验的不足之处主要表现在： 代码的灵活性较低，在爬取网页的时候需要手工进行，且需要对中文和英文分别进行，应该完善代码使得对网页的语言有个判定，然后自动选择执行不同的分词器。 代码的复用性较低，没有较为合理的分类和方法的构建，为了简便，基本在几个核心代码中进行注释和标记而实现效果，有待改进。 代码的可移植性较低，对网页的爬取使用的是JDK1.6的版本，LUCENE的实现使用的是JDK1.8的版本，在导出到其他机器上，需要对环境稍加修改和配置，无法实现一键式操作。 8 总结本文从Lucene的原理出发，了解了全文检索的思路和方法，并对常用的功能进行了实验和测试。在实验的过程中，了解了搜索引擎的原理，基于信息检索课程的内容上，有了一个更好的实操体验。Lucene 是一个优秀的开源全文本搜索技术框架，通过对它的深入研究，对其实现机制更加熟悉，在研究它的过程中学习了很多面向对象的编程方法和思想，它良好的系统框架和扩展性值得学习借鉴。]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>Lucene、索引、检索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决微信小程序本地资源无法通过WXSS获取的问题]]></title>
    <url>%2F2018%2F10%2F18%2Fbackground-image%2F</url>
    <content type="text"><![CDATA[### 微信开发工具中，本地资源无法通过WXSS获取 background-image：//可以使用网络图片，或者base64，或者使用&lt;image/&gt;标签。 网络图片即在网上右键 → 复制图片地址即可。转base地址： https://www.css-js.com/tools/base64.html]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序 base64</tag>
      </tags>
  </entry>
</search>
